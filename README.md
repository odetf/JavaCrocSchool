# Тарасенко Ольга: https://t.me/oatarasenko

Репозиторий для сдачи домашних заданий и финального проекта в рамках Java школы 2022.

Навигация по заданиям:

### **Task 2**
Написать программу, которая принимает 3 аргумента, и считает сумму арифметической прогрессии.
Аргументы: начальный элемент, разность арифметической прогрессии и кол-во членов прогрессии.
Решить с помощью использования циклов, а не формулы суммы.

### **Task 3**
Реализовать функцию, вычисляющую площадь треугольника по координатам его вершин в декартовой системе координат. Результат вывести на экран.
Для задания координат можно определить вспомогательный класс Point.
Для вычисления площади можно использовать формулу Герона или применить геометрические свойства векторного произведения. Функция извлечения квадратного корня в Java: Math.sqrt(x).

Входные данные
Программа получает входные параметры с консоли, каждую координату отдельно для каждой вершины.
Пример вызова программы
% java ru/croc/task1/Main 0 0 0 2 2 0
% Площадь треугольника: 2

### **Task 4**
В приложении определен класс аннотированного изображения:

class AnnotatedImage {
   private final String imagePath;
   private final Annotation[] annotations;
   
   public AnnotatedImage(String imagePath, Annotation... annotations) {
       this.imagePath = imagePath;
       this.annotations = annotations;
   }

   public String getImagePath() {
       return this.imagePath;
   }

   public Annotation[] getAnnotations() {
       return this.annotations;
   }
}


Определите класс Annotation для представления данных разметки (данные: подпись и фигура) и классы Figure, Rectangle, Circle для задания размеченных областей.
Прямоугольники определяются координатами левого нижнего и правого верхнего углов, а окружности - координатами центра и радиусом.
Переопределите метод toString класса Annotation так, чтобы в результат выводилась информация о полях и вложенных объектах. Формат вывода:

Окружность:
“Circle (<X0>, <Y0>), <R>: <Подпись>”

Прямоугольник:
“Rectangle (<X1>, <Y1>), (<X2>, <Y2>): <Подпись>”

Например:
Circle (100, 100), 10: Tree
Rectangle (100, 100), (150, 200): Car

### **Task 5**
От пользователей приложения (см. задачу 4) пришел запрос на возможность перемещать уже размеченные области. Для поддержки новой функциональности вам требуется внести несколько изменений: 

1) выбор аннотации по координатам точки (x, y);
В массиве аннотаций требуется найти первую, фигура которой содержит точку с заданными координатами.

Annotation findByPoint(int x, int y) {
  // ...
}

2) выбор аннотации по шаблону подписи;
В массиве аннотаций требуется найти первую, подпись которой содержит заданную подстроку.

Annotation findByLabel(String label) {
  // ...
}
Определить, содержит ли строка заданную подстроку, можно с помощью метода contains(CharSequence s) класса String.

3) перемещение фигуры выбранной аннотации на смещение (dx, dy);

В рамках этого изменения вы решили доработать классы фигур таким образом, чтобы они реализовывали интерфейс

public interface Movable {
  void move(int dx, int dy);
}

Доработайте классы и реализуйте соответствующие методы.

### **Task 6**
В текстах программ на Java могут использоваться многострочные (/* ... */) и однострочные (// ...) комментарии. Реализовать метод, принимающий на вход строковую переменную - исходный текст программы на Java, вырезающий из этой строки все комментарии и возвращающий результат в виде строки.


Можно задать source строку так, как в примере ниже или прочитать из файла.


public static void main(String[] args) {
  String source = “...”; // test data
  String noComments = removeJavaComments(source);
  System.out.println(noComments);
}
Пример
/*
 My first ever program in Java!
 */
class Hello { // class body starts here 
  
  /* main method */
  public static void main(String[] args/* we put command line arguments here*/) {
    // this line prints my first greeting to the screen
    System.out.println("Hi!"); // :)
  }
} // the end
// to be continued...
Результат
class Hello {  
  
  
  public static void main(String[] args) {
    
    System.out.println("Hi!"); 
  }
} 

### **Task 7**
Определить класс, описывающий позицию на шахматной доске 8x8. Данные класса: компоненты x и y, отсчитываемые от левого нижнего угла (x = 0, y = 0 - левая нижняя клетка).

Все методы, позволяющие установить координаты, в том числе и конструкторы, должны проверять корректность аргументов и генерировать IllegalPositionException (необходимо определить это исключение самостоятельно) в случае ошибочных значений.

Переопределить метод toString(), выводящий координаты позиции в формате <номер колонки в виде буквы от 'a' до 'h'><номер строки, начиная с 1>. Например, позиция с координатами (1, 1) имеет строковое представление "b2".

Реализовать "фабричный метод" конструирования объекта позиции из строкового представления ("b2" -> объект):

static ChessPosition parse(String position) {
  // ...
}

В виде массива строк задана некоторая последовательность позиций на шахматной доске 8x8. Например, "b1", "a3", "c4", "d6". Реализовать метод, проверяющий, что последовательность может быть пройдена фигурой конь в соответствии с правилами хода этой фигуры (буквой "Г"). На вход метод принимает массив объектов класса, определенных в текущей задаче.

Определить новый класс IllegalMoveException обрабатываемого исключения, которое генерируется методом проверки в случае ошибки. Класс должен содержать информацию о неправильном ходе: из какой в какую позиции ход запрещен. При вызове метода проверки это исключение должно обрабатываться, а неправильный ход выводиться на экран. Последовательность ходов для проверки задается в аргументах командной строки программы.

public class IllegalMoveException extends Exception {
  // ...
}
Тестовые примеры
[in]  "g8", "e7", "e6"
[out] "конь так не ходит: e7 -> e6"

[in]  "g8", "e7", "c8"
[out] "OK"

Определить класс, описывающий позицию на шахматной доске 8x8. Данные класса: компоненты x и y, отсчитываемые от левого нижнего угла (x = 0, y = 0 - левая нижняя клетка).

Все методы, позволяющие установить координаты, в том числе и конструкторы, должны проверять корректность аргументов и генерировать IllegalPositionException (необходимо определить это исключение самостоятельно) в случае ошибочных значений.

Переопределить метод toString(), выводящий координаты позиции в формате <номер колонки в виде буквы от 'a' до 'h'><номер строки, начиная с 1>. Например, позиция с координатами (1, 1) имеет строковое представление "b2".

Реализовать "фабричный метод" конструирования объекта позиции из строкового представления ("b2" -> объект):

static ChessPosition parse(String position) {
  // ...
}

В виде массива строк задана некоторая последовательность позиций на шахматной доске 8x8. Например, "b1", "a3", "c4", "d6". Реализовать метод, проверяющий, что последовательность может быть пройдена фигурой конь в соответствии с правилами хода этой фигуры (буквой "Г"). На вход метод принимает массив объектов класса, определенных в текущей задаче.

Определить новый класс IllegalMoveException обрабатываемого исключения, которое генерируется методом проверки в случае ошибки. Класс должен содержать информацию о неправильном ходе: из какой в какую позиции ход запрещен. При вызове метода проверки это исключение должно обрабатываться, а неправильный ход выводиться на экран. Последовательность ходов для проверки задается в аргументах командной строки программы.

public class IllegalMoveException extends Exception {
  // ...
}
Тестовые примеры
[in]  "g8", "e7", "e6"
[out] "конь так не ходит: e7 -> e6"

[in]  "g8", "e7", "c8"
[out] "OK"

### **Task 8**
Предположим, вам необходимо написать небольшую утилиту, которая могла бы печатать ценники в читаемом виде.

Напишите простую программу, которая предлагала бы пользователю ввести число в консоль и выводила его обратно в отформатированном виде.
Чтобы считать число из консоли можно воспользоваться классом Scanner (у него есть удобные методы nextDouble, nextLine, nextInt), указав ему в кач-ве входного потока System.in.
Locale для вывода можете выбрать самостоятельно.
Предусмотрите обработку исключений при некорректном вводе числа.

Пример работы подобной программы:

Enter a double: 52,30
Result: ₩52

### **Task 9**
Вы “ответственно” подходите к информационной безопасности и храните свои пароли в файлах в виде MD5-хешей (https://ru.wikipedia.org/wiki/MD5, https://www.baeldung.com/java-md5).

Но, к сожалению, вы забыли и никак не можете вспомнить свой пароль от учетной записи в почте. Хотя у вас остался его хеш 40682260CC011947FC2D0B1A927138C5. Вы точно помните, что пароль состоял из 7 букв латинского алфавита, и что все они были строчными.

Для генерации хеша вы используете функцию hashPassword

private static final char[] HEX_DIGITS = "0123456789ABCDEF".toCharArray();

private static String toHexString(byte[] bytes) {
  StringBuilder hex = new StringBuilder(bytes.length * 2);
  for (byte b : bytes) {
    hex.append(HEX_DIGITS[(b & 0xff) >> 4]);
    hex.append(HEX_DIGITS[b & 0x0f]);
  }
  return hex.toString();
}

private static String hashPassword(String password) {
  MessageDigest digest;
  try {
    digest = MessageDigest.getInstance("MD5");
  } catch (NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
  }
  digest.update(password.getBytes());
  byte[] bytes = digest.digest();
  return toHexString(bytes);
}

Напишите программу, которая методом полного перебора (https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%BD%D1%8B%D0%B9_%D0%BF%D0%B5%D1%80%D0%B5%D0%B1%D0%BE%D1%80) напомнит вам пароль. Причем за наиболее короткий срок - пароль вам нужен как можно быстрее. Для ускорения процесса вы решили перебор выполнять в несколько потоков.

Количество потоков - входные данные для программы, задается первым аргументом командной строки. Хеш пароля - вторым аргументом. Найденный пароль печатается в стандартный поток вывода.

### **Task 10**
Вы работаете над приложением для проведения аукциона. Начать разработку решили с самого важного - класса лота аукциона. В ходе анализа предметной области вы пришли к выводу, что каждый лот должен иметь 3 параметра: текущую стоимость, имя пользователя, предложившего ее, и время окончания торгов по этому лоту. 

Также класс должен предоставлять два метода - метод “ставки”, который обновляет текущую стоимость лота и сохраняет предложившего ее пользователя, если торги по лоту еще ведутся по времени и предложенная цена выше текущей. Второй метод - метод получения имени пользователя победителя.

Делать ставки на лот одновременно могут сразу несколько пользователей.

Реализуйте класс по описанию так, чтобы одновременное участие в ставках большого количества пользователей не приводило к ошибкам в проведении аукциона (то есть, потокобезопасно).

### **Task 11**
Напишите клиент-серверное приложение (это 2 отдельных приложения).
Сервер ждет подключения пользователей, принимает текстовые сообщения, которые пересылает всем подключенным клиентам.
Клиентское приложение сначала предлагает ввести никнейм, а далее отсылает на сервер каждую строку введённую пользователем
И выводит на консоль все сообщения полученные с сервера. 
IP адрес - 127.0.0.1 - ведёт на так называемый localhost. Если запускаете клиент и сервер с одной машины - указывайте его. Если пробуете с кем то сконектиться - то надо указать или его IP адрес в локальной сети (Или если есть внешний IP - можно попробовать законектиться с любой точки мира указав его)


### **Task 12**
Небольшой стартап разрабатывает социальный сервис, в котором пользователи могут оставлять комментарии. Со временем в комментариях появился спам и разработчики решили бороться с ним с помощью "черных списков" запрещенных слов. Они составили такие списки и поручили вам написать функцию, удаляющую из всех накопленных комментариев нежелательные.

Они предоставили вам интерфейс, который внедрили в свой продукт, и попросили написать его реализацию:

import java.util.List;
import java.util.Set;

public interface BlackListFilter {
  void filterComments(List<String> comments, Set<String> blackList);
}

Реализуйте интерфейс BlackListFilter.
В методе main покажите вариант использования вашего фильтра.

### **Task 13**
Кинотеатр "Места для поцелуев" открыл стриминговый сервис для онлайн-просмотра фильмов. За несколько месяцев работы сервиса накопилась история просмотров разными пользователями и владельцы решили внедрить в него систему рекомендаций, которая предлагала бы пользователям интересный фильм на основе их истории просмотров.

У вас есть два файла (их тоже запушьте к себе в репозиторий, пожалуйста):

1. Список доступных фильмов. Каждая строка содержит числовой идентификатор фильма и его название, разделенные запятой. Например:

1,Мстители: Финал
2,Хатико
3,Дюна
4,Унесенные призраками

2. История просмотров по всем пользователям сервиса. Каждая строка файла содержит список идентификаторов фильмов, просмотренных одним человеком за все время пользования сервисом. Идентификаторы разделены запятыми. Например:

2,1,3
1,4,3
2,2,2,2,2,3

На основе этих данных реализуйте алгоритм рекомендаций, который бы для списка просмотров конкретного пользователя рекомендовал следующий фильм. 

Алгоритм выбора рекомендации:

1. Для просмотров пользователя из историй по всем пользователям выбираются те, у которых хотя бы половина фильмов совпадает с заданной. (То есть, выбираются все пользователи, которые посмотрели минимум половину фильмов пользователя, для которого формируется рекомендация.)
2. Из отобранных списков исключаются все, которые пользователь уже посмотрел.
3. Для оставшегося списка фильмов подсчитывается суммарное количество просмотров среди всех пользователей сервиса и фильм с максимальным числом просмотров выбирается как рекомендация (если таких фильмов оказалось несколько, выбирается любой из них).

Список просмотров текущего пользователя задается через пользовательский ввод, рекомендация выдается в виде названия фильма в System.out. Пути к файлам с названиями фильмов и истории просмотров пользователей сервиса могут быть определены в виде констант в приложении.

Пример:
[in]
2,4

[out]
Дюна


### **Task 14**
Вы реализовали фильтрацию комментариев по “черному списку” слов (задача 12) и с чистой совестью ушли в отпуск на 3 недели.

По возвращении из отпуска вы обнаружили, что логика фильтрации усложнилась. Также выяснилось, что нет единого способа представления комментариев среди сервисов: где-то они представлены строками, где-то объектами специализированных классов. Вдобавок некоторым сервисам оказалось неудобным передавать набор комментариев на фильтрацию в виде списка и предпочтительнее коллекция другого типа. 

В результате разработчики разных сервисов реализовали копии методов для применения правил “черного списка”, учитывающие специфику их сервисов. А так как правила фильтрации тоже менялись в процессе, эти методы правились не совместно, что привело к плохо читаемому и поддерживаемому коду: логика с одной стороны дублируется, но с другой - работает в каждом методе по-особенному.

Вы берете дело в свои руки и решаете реализовать единый метод фильтрации, учитывающий все обнаруженные особенности. В ходе анализа кода вы отмечаете для себя следующее:

1. Условия фильтрации в разных сервисах различаются и нет возможности обобщить их в рамках одного метода. Поэтому способ фильтрации вы решаете представлять в виде предиката и позволять определять его вызывающим сервисам.
2. Набор используемых сервисами классов-представлений для комментариев обширен (String, Comment, CommentDto, …) и, возможно, будет и в дальнейшем расширяться.
3. Сервисы работают с наборами комментариев в виде коллекций разных типов (HashSet, ArrayList, ArrayDeque, …), но все они имплементируют интерфейс Iterable.
4. Результат фильтрации удобнее представлять в виде отдельной коллекции-возвращаемого значения метода, а исходную коллекцию при этом не модифицировать. Некоторым сервисам важен порядок следования комментариев, поэтому он должен быть сохранен в отфильтрованном результате.

Обновите интерфейс BlackListFilter и реализуйте новый механизм фильтрации в виде default-метода


### **Task 15**
Ваша команда разрабатывает приложение для проведения социологических опросов. Вы работаете над модулем разбивки респондентов по возрастным группам. При этом модуль вы реализуете в виде отдельного Java-приложения, работающего со стандартными потоками ввода-вывода. На вход (System.in) оно принимает список участников опроса в текстовом виде, на выходе (System.out) выдает их разбивку по группам возрастов.

В качестве аргументов командной строки приложению указывается последовательность чисел, задающих границы возрастных групп.
Пример
18 25 35 45 60 80 100

Эта последовательность определяет возрастные группы: от 0 до 18 лет, от 19 до 25 лет, от 26 до 35 лет и так далее. Последняя группа: от 101 года и старше.

Входные данные (список респондентов) задаются в виде строк:
<ФИО>,<возраст>

Строка END сигнализирует об окончании списка.

Выходные данные (разбивка по возрастным группам) представлены как последовательность строк следующего формата:
<Группа>: <ФИО_1> (возраст_1), <ФИО_2> (возраст_2), …, <ФИО_N> (возраст_N)

При этом:

* группы строк перечисляются в порядке от старшей к младшей
* в каждой группе перечисляются только респонденты, попадающие в нее по возрасту
* список респондентов в каждой группе отсортирован по возрасту в порядке убывания, если возраст совпадает - по ФИО в порядке возрастания
* если в возрастную группу не попадает ни один из респондентов, строка с этой группой не выводится

Пример
101+: Кошельков Захар Брониславович (105)
81-100: Дьячков Нисон Иринеевич (88), Иванов Варлам Якунович (88)
46-60: Старостин Ростислав Ермолаевич (50)
26-35: Ярилова Розалия Трофимовна (29)
0-18: Соколов Андрей Сергеевич (15), Егоров Алан Петрович (7)

При реализации можно учитывать, что:

нет людей старше 123 лет
в рамках одного опроса не может встретиться полных однофамильцев с одинаковыми возрастами

Реализуйте приложение. При этом постарайтесь продумать структуру данных и использовать коллекции, максимально подходящие для поставленных целей.

### **Task 16**
Ваша команда разрабатывает приложение службы такси. Вы работаете над модулем подбора водителя. При этом модуль вы реализуете в виде отдельного Java-приложения, работающего со стандартными потоками ввода-вывода. На вход (System.in) оно принимает координаты клиента, класс комфорта и список особых пожеланий в текстовом виде, на выходе (System.out) выдает идентификатор ближайшего водителя на подходящем авто.

В качестве входных данных приложению указывается следующая последовательность: координаты в формате <Широта, долгота>, класс комфорта, список особых пожеланий.

Компаратор для сортировки реализуйте в виде лямбды.
Особые пожелания — конечный набор значений.
Пример
59.9386, 30.3141
Комфорт
Детское кресло

Выходные данные представлены как идентификатор водителя.

При этом:

* Класс автомобиля соответствует заявленному
* Авто подходит под особые пожелания клиента
* Расстояние до клиента - наименьшее среди водителей, подходящих под требования


### **Task 17**
Вы разрабатываете бэкенд интернет-магазина. Магазин уже функционирует и принимает заказы. Информация о заказах регистрируется в Excel-таблице вручную. В нее внесены данные за все время существования магазина. Заказчик выгрузил и передал вам эту таблицу в виде CSV-файла.

Формат файла
<номер_заказа:integer>,<логин_пользователя:string>,<артикул_товара:string>,<название_товара:string>,<цена_в_рублях:integer>

Содержимое
1,vasya,Т1,Монитор,500
1,vasya,Т2,Мышь,50
2,petya,Т2,Мышь,50
2,petya,Т2,Мышь,50	
2,petya,Т3,Клавиатура,150
1,vasya,Т4,Блок питания, 200
3,nikita,Т4,Блок питания, 200
4,olga,Т4,Блок питания, 200
3,nikita,Т5,Видеокарта,15000
3,nikita,Т5,Видеокарта,15000
4,olga,Т5,Видеокарта,15000
4,olga,Т5,Видеокарта,15000

Дополнительно заказчик сообщил, что товары с одинаковым артикулом всегда продавались с одними и теми же названием и ценой.

Спроектируйте структуру таблиц для представления информации о заказах в базе данных и загрузите в них данные из файла. Для этого разработайте приложение, которое:
* Создаст в базе данных все необходимые таблицы.
* Импортирует в базу данных все записи исходного файла.

Путь к файлу с данными передается программе в качестве аргумента командной строки при запуске.

### **Task 18**
Вы продолжаете разработку бэкенда интернет-магазина. Уже спроектирована схема данных и есть первичное наполнение, следующим шагом вы решаете разработать DAO-класс для работы с базой данных заказов. Для этого вы добавляете в приложение классы сущностей заказа (Order) и товара (Product) и определяетесь с составом необходимых методов DAO-класса:

Product findProduct(String productCode);
Поиск в базе данных товара с указанным артикулом. Если соответствующего товара в базе данных нет, метод возвращает null.

Product createProduct(Product product);
Создание нового товара. Если в базе данных существует товар с переданным артикулом, метод выбрасывает исключение.

Product updateProduct(Product product);
Изменение информации о товаре. Название и цена товара в базе данных заменяется на значения, указанные в полях параметра product. Артикул товара, данные которого должны быть изменены, также задается полем объекта product.

void deleteProduct(String productCode);
Удаление товара и всех упоминаний о нем в заказах. Вас смущает необходимость изменения уже выданных заказов, но заказчик настаивает.

Order createOrder(String userLogin, List<Product> products);
Создание заказа. Для указанного пользователя в базе данных создается новый заказ с заданным списком товаров.

Не забудьте протестировать собственное решение (любым способом, можно просто вызывать требуемые методы из main-метода с произвольными параметрами.
Реализуйте программу с указанными операциями.

### **Task 19**
Вы продолжаете разработку интернет-магазина.
Теперь в магазине доступна курьерская доставка. Соответственно, у заказа есть время доставки.
У курьера есть фамилия, имя, номер сотрудника.

Разработайте следующую функциональность:
1. Получение по id пользователя времени доставки всех его заказов вместе с именами курьеров, которые эти заказы выполняют.
2. Получение по id курьера всех заказов, которые ему нужно доставить (вместе с именами получателей).

В main продемонстрируйте работу программы

**Примечание:** Данный файл ещё требует доработки
